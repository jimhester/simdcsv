---
title: "Error Handling"
---

## Overview

simdcsv provides a comprehensive error handling framework with configurable behavior. The parser can detect 16 different error types with three severity levels.

## Error Modes

The parser supports three error handling modes:

| Mode | Behavior |
|------|----------|
| `STRICT` | Stop on first error |
| `PERMISSIVE` | Collect all errors, try to recover |
| `BEST_EFFORT` | Ignore errors, parse what's possible |

```cpp
#include "error.h"

// Create collectors with different modes
simdcsv::ErrorCollector strict(simdcsv::ErrorMode::STRICT);
simdcsv::ErrorCollector permissive(simdcsv::ErrorMode::PERMISSIVE);
simdcsv::ErrorCollector best_effort(simdcsv::ErrorMode::BEST_EFFORT);
```

## Error Types

### Quote-Related Errors

| Error Code | Description | Severity |
|------------|-------------|----------|
| `UNCLOSED_QUOTE` | Quoted field not closed before EOF | FATAL |
| `INVALID_QUOTE_ESCAPE` | Invalid quote escape sequence | ERROR |
| `QUOTE_IN_UNQUOTED_FIELD` | Quote appears in middle of unquoted field | ERROR |

**Example - Unclosed quote:**
```csv
name,description
Alice,"Hello World
Bob,Hi
```

### Field Structure Errors

| Error Code | Description | Severity |
|------------|-------------|----------|
| `INCONSISTENT_FIELD_COUNT` | Row has different number of fields than header | ERROR |
| `FIELD_TOO_LARGE` | Field exceeds maximum size limit | ERROR |

**Example - Inconsistent fields:**
```csv
name,age,city
Alice,30
Bob,25,NYC,USA
```

### Line Ending Errors

| Error Code | Description | Severity |
|------------|-------------|----------|
| `MIXED_LINE_ENDINGS` | File uses inconsistent line endings | WARNING |
| `INVALID_LINE_ENDING` | Invalid line ending sequence | ERROR |

### Encoding Errors

| Error Code | Description | Severity |
|------------|-------------|----------|
| `INVALID_UTF8` | Invalid UTF-8 sequence | ERROR |
| `NULL_BYTE` | Unexpected null byte in data | ERROR |

### Structure Errors

| Error Code | Description | Severity |
|------------|-------------|----------|
| `EMPTY_HEADER` | Header row is empty | ERROR |
| `DUPLICATE_COLUMN_NAMES` | Header contains duplicate column names | WARNING |

## Severity Levels

| Severity | Meaning |
|----------|---------|
| `WARNING` | Non-fatal, parser continues (e.g., mixed line endings) |
| `ERROR` | Recoverable, can skip affected row |
| `FATAL` | Unrecoverable, parsing must stop |

## Using the ErrorCollector

```cpp
#include "error.h"
#include "two_pass.h"

void parse_with_errors(const uint8_t* buf, size_t len) {
    // Create parser and error collector
    simdcsv::two_pass parser;
    auto idx = parser.init(len, 1);
    simdcsv::ErrorCollector errors(simdcsv::ErrorMode::PERMISSIVE);

    // Parse with error collection
    bool success = parser.parse_with_errors(buf, idx, len, errors);

    // Check for errors
    if (errors.has_errors()) {
        std::cout << "Found " << errors.error_count() << " errors\n";

        // Iterate through errors
        for (const auto& err : errors.errors()) {
            std::cout << "Line " << err.line
                      << ", Col " << err.column
                      << ": " << err.message << "\n";
        }
    }

    // Check specific conditions
    if (errors.has_fatal_errors()) {
        std::cerr << "Fatal error encountered!\n";
    }

    // Get summary
    std::cout << errors.summary() << "\n";
}
```

## Error Limits

To prevent out-of-memory issues with malformed files containing many errors, ErrorCollector has a configurable maximum error limit:

```cpp
// Default limit is 10,000 errors
simdcsv::ErrorCollector errors(simdcsv::ErrorMode::PERMISSIVE);

// Custom limit
simdcsv::ErrorCollector errors(simdcsv::ErrorMode::PERMISSIVE, 1000);

// Check if limit reached
if (errors.at_error_limit()) {
    std::cerr << "Error limit reached, some errors may not be reported\n";
}
```

## Multi-threaded Error Collection

When parsing with multiple threads, each thread collects errors locally. After parsing, errors are merged and sorted by byte offset:

```cpp
simdcsv::two_pass parser;
auto idx = parser.init(len, 4);  // 4 threads
simdcsv::ErrorCollector errors(simdcsv::ErrorMode::PERMISSIVE);

// Errors will be collected per-thread and merged
parser.parse_two_pass_with_errors(buf, idx, len, errors);

// Errors are sorted by byte offset for consistent ordering
for (const auto& err : errors.errors()) {
    // Process errors in file order
}
```

## Test Files

The test suite includes 16+ malformed CSV files in `test/data/malformed/` covering all error types:

- `unclosed_quote.csv` - Unclosed quote in middle of file
- `unclosed_quote_eof.csv` - Unclosed quote at end of file
- `invalid_quote_escape.csv` - Invalid escape sequences
- `quote_in_unquoted_field.csv` - Quote in unquoted context
- `inconsistent_columns.csv` - Varying field counts
- `mixed_line_endings.csv` - LF and CRLF mixed
- `null_byte.csv` - Embedded null characters
- `empty_header.csv` - Missing header row
- `duplicate_column_names.csv` - Repeated column names
- And more...

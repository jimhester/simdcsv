#!/bin/bash
set -uo pipefail

# test-scsv-files - Test scsv CLI against a collection of CSV files
#
# Usage: ./scripts/test-scsv-files [--verbose]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SCSV="${REPO_ROOT}/build/scsv"

VERBOSE=false
[[ "${1:-}" == "--verbose" ]] && VERBOSE=true

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'

# Counters
TOTAL=0
PASSED=0
FAILED=0
WARNINGS=0
FAILURES=""

# Check scsv exists
if [[ ! -x "$SCSV" ]]; then
    echo "Error: scsv not found at $SCSV"
    exit 1
fi

echo "scsv CLI Test Suite"
echo "==================="
echo "scsv: $SCSV"
echo "Version: $($SCSV --version 2>&1)"
echo ""

# Build file list
FILES=$(find "${REPO_ROOT}/test/data" -name "*.csv" -type f 2>/dev/null)
FILES="$FILES
$(ls /usr/share/distro-info/*.csv 2>/dev/null || true)
$(ls /usr/share/doc/gawk/examples/misc/*.csv 2>/dev/null || true)"

# Include CSV_Wrangling test data if available (all files)
if [[ -d /tmp/CSV_Wrangling/data/github ]]; then
    FILES="$FILES
$(find /tmp/CSV_Wrangling/data/github -name "*.csv" -type f 2>/dev/null)"
fi

FILE_COUNT=$(echo "$FILES" | grep -c . || echo 0)
echo "Found $FILE_COUNT CSV files"
echo ""
echo "Running tests..."
$VERBOSE || echo -n "Progress: "

# Test commands (only valid scsv commands)
CMDS="head:-n:5
tail:-n:5
dialect
sample:-n:3
count
info
pretty:-n:5"

while IFS= read -r file; do
    [[ -z "$file" || ! -f "$file" ]] && continue

    $VERBOSE && echo "Testing: $file"

    file_failed=0

    while IFS= read -r cmd_line; do
        [[ -z "$cmd_line" ]] && continue

        # Split on : to get command and args
        IFS=':' read -ra parts <<< "$cmd_line"
        cmd_name="${parts[0]}"
        args=("${parts[@]:1}")

        TOTAL=$((TOTAL + 1))

        # Run test with timeout (command name first, then args, then file)
        # Write output to temp file to avoid bash null byte issues
        tmpfile="/tmp/scsv_test_$$"
        timeout 10 "$SCSV" "$cmd_name" "${args[@]}" "$file" >"$tmpfile" 2>&1 || exit_code=$?
        exit_code=${exit_code:-0}

        if [[ $exit_code -gt 128 ]]; then
            # Crash (signal)
            sig=$((exit_code - 128))
            echo -e "\n${RED}CRASH${NC}: $cmd_name on $(basename "$file")"
            echo "  Signal: $sig"
            echo "  File: $file"
            FAILED=$((FAILED + 1))
            file_failed=$((file_failed + 1))
            FAILURES="$FAILURES  - $cmd_name: $file (signal $sig)\n"
        elif [[ $exit_code -eq 124 ]]; then
            # Timeout
            $VERBOSE && echo -e "${YELLOW}TIMEOUT${NC}: $cmd_name"
            WARNINGS=$((WARNINGS + 1))
        elif grep -qi "segmentation fault\|segfault\|core dumped\|SIGSEGV\|SIGABRT" "$tmpfile" 2>/dev/null; then
            echo -e "\n${RED}CRASH${NC}: $cmd_name on $(basename "$file") (crash indicator in output)"
            FAILED=$((FAILED + 1))
            file_failed=$((file_failed + 1))
            FAILURES="$FAILURES  - $cmd_name: $file (crash)\n"
        elif [[ $exit_code -ne 0 ]]; then
            # Non-zero exit (expected for malformed)
            $VERBOSE && echo -e "${YELLOW}WARN${NC}: $cmd_name exit $exit_code"
            WARNINGS=$((WARNINGS + 1))
        else
            PASSED=$((PASSED + 1))
        fi

        rm -f "$tmpfile"
        exit_code=0
    done <<< "$CMDS"

    $VERBOSE || { [[ $file_failed -gt 0 ]] && echo -ne "${RED}X${NC}" || echo -n "."; }
done <<< "$FILES"

$VERBOSE || echo ""
echo ""
echo "==================="
echo "Results Summary"
echo "==================="
echo "Total: $TOTAL"
echo -e "${GREEN}Passed${NC}: $PASSED"
echo -e "${YELLOW}Warnings${NC}: $WARNINGS"
echo -e "${RED}Failed${NC}: $FAILED"

if [[ $FAILED -gt 0 ]]; then
    echo ""
    echo "Failures:"
    echo -e "$FAILURES"
    exit 1
fi

echo -e "\n${GREEN}All tests passed!${NC}"
